import importlib, io, pprint

# Set primary input file name (without suffix .py)
input_module_name = "sm0_15_cvf75_exponential4s"

# Specify whether conduit is coupled to 2D atmosphere.
# If True, run `generate_atm_partitions.py`` as well to write the atmosphere
# files.
is_coupled2D = False

# Import primary input file
primary_input = importlib.import_module(input_module_name)

# Set header to write, including necessary imports
header = '''\'\'\' Input file generated by generate_conduit_partitions.py. \'\'\'

import numpy as np
import scipy.interpolate as si

def exponential_timeSeries(end_time, dt, SEED, std_dev, cor_len, max_freq):
  t = np.linspace(0,end_time+dt,int((end_time+dt) / dt))
  R_t = std_dev**2 * np.exp(-np.abs(t)/cor_len)

  N = len(t) # number of Fourier sample points
  h = t[1]-t[0] # grid spacing, nominally h=0.1 km for r=1
  L = N*h # profile length

  # white noise, unit normal distribution
  randomGen = np.random.default_rng(seed=SEED)
  y = randomGen.normal(size=N)
  # scale so PSD has unit amplitude
  y = y*np.sqrt(N/L)

  omega = 2 * np.pi * np.fft.fftfreq(N, h)
  Y = np.fft.fft(y)*h

  # apply exponential PSD
  PSD_exponential = np.fft.fft(R_t) * h
  PSD_exponential[np.abs(omega) > max_freq * 2 * np.pi] = 0

  Y_exponential = Y * np.sqrt(PSD_exponential)
  Y_exponential[0] = 0
  Y_exponential[-1] = 0
  PSDy_exponential = np.abs(Y_exponential)**2/L

  # transforming back into time domain
  y_exponential = np.fft.ifft(Y_exponential) / h
  y_exponential = np.real(y_exponential) - np.real(y_exponential)[0]

  exponential = si.interp1d(t, y_exponential, kind='cubic', bounds_error=False, fill_value="extrapolate")
  return exponential

'''

''' Specify mesh partition here ''' 

num_domains = 10
# Specify mesh partition (overriding the Mesh in primary_input)
num_elems_total = 2000
# Specify extent of domain
x_global_min = -1150
x_global_max = -150
if num_domains * (num_elems_total//num_domains) != num_elems_total:
  raise ValueError("Domain could not be split evenly into domain. Check that" +
    "num_elems_total is an integer multiple of num_domains.")

domain_length = x_global_max - x_global_min 
manual_meshes = [
  {
    "File" : None,
    "ElementShape" : "Segment",
    "NumElemsX" : num_elems_total//num_domains,
    "xmin" : x_global_min + (domain_length/num_domains)*i,
    "xmax" : x_global_min + (domain_length/num_domains)*(i+1),
  }
  for i in range(num_domains)
]
manual_bcs = [
  {
    "x1":{
      "BCType": "MultiphasevpT1D1D",
      "bkey": f"comm1D_{i-1}_{i}",
    },
    "x2":{
      "BCType": "MultiphasevpT1D1D",
      "bkey": f"comm1D_{i}_{i+1}",
    },
  }
  for i in range(num_domains)
]
# First BC at bottom is copied
manual_bcs[0]["x1"] = primary_input.BoundaryConditions["x1"]

# Set last BC at top of 1D domain
if is_coupled2D:
  manual_bcs[-1]["x2"] = { 
      "BCType" : "MultiphasevpT2D1D",
      "bkey" : "vent",
  }
else:
  manual_bcs[-1]["x2"] = { 
    "BCType" : "PressureOutlet1D",
    "p": 1e5,
  }

# Whether to approximate periodically forced mass fraction in space
approx_massfracs = True
# Define periodic source-time function as strings
str_yC_source = "lambda t: 0.4"
str_yWt_source = "lambda t: 0.03 * (1.0 - 0.4) / (1.0 + 0.03)"
#str_yC_source = "lambda t:  0.4 * (1.1 - 0.1 * np.cos(2*np.pi*0.5*t))"
#str_yWt_source = "lambda t: 0.03 * (1 - 0.4) / (1 + 0.03)"

cVFfunc = "exponential_timeSeries(TimeStepping[\"FinalTime\"], 0.04, 1, 0.02, 10, 0.25)"

# Define name of the parameter file
param_filename_map = lambda i: f'sm0_15_cvf75_exponential4s_conduit_sub{i}.py'
# Define name of the atm parameter files
atm_param_filename_map = lambda i: f'atm_sub{i}.py'

''' ==================== Machinery ==================== '''

# Designate fields to copy as default
fields_copy = ["Numerics", "Mesh", "Physics", "SourceTerms",
  "Output", "InitialCondition", "ExactSolution",
  "BoundaryConditions", "LinkedSolvers"]

class Evaluable():
  ''' Evaluable expression. Used if an expression needs to be embedded in the
  generated parameter file. This class allows evaluable expressions to be
  passed through pprint without adding quotation marks.'''

  def __init__(self, expr):
    self.expr = expr

  def __repr__(self):
    return self.expr

# Construct global mesh representation (uniform mesh)
#   Note that for SolutionOrder > 2, this does not correspond exactly to the
#   required DG nodes. This may cause numerical perturbation in the initial
#   condition setup.
#   Format of _subdomain_nodes[i] is (x_min, x_max, num_nodes)

# Get mesh representations as (x_min, x_max, N_nodes) in each subdomain mesh
if primary_input.Numerics["SolutionOrder"] == 0:
  # Compute dx for centering sampling nodes in 0th order elements
  _elt_sizes = [(mesh["xmax"] - mesh["xmin"]) / mesh["NumElemsX"]
    for mesh in manual_meshes]
  _subdomain_nodes = [(mesh["xmin"] + dx/2, mesh["xmax"] - dx/2,
    mesh["NumElemsX"]) for mesh, dx in zip(manual_meshes, _elt_sizes)]
else:
  # Compute node locations
  _subdomain_nodes = [(mesh["xmin"], mesh["xmax"],
    1 + primary_input.Numerics["SolutionOrder"] * mesh["NumElemsX"])
  for mesh in manual_meshes]
# Get evaluable expression for global mesh
evaluable_str = ', '.join(
  [f"np.linspace({arg[0]:.3e}, {arg[1]:.3e}, {arg[2]:d})"
  for arg in _subdomain_nodes])
x_global = Evaluable(f"np.unique(np.hstack([{evaluable_str}]))")

# Subdomain control
for subdomain_idx in range(num_domains):
  # Initialize dictionary representation of parameter file to be written
  dict_repr = {field: getattr(primary_input, field).copy()
    for field in fields_copy}
  # Modify name for simulation output files
  dict_repr["Output"]["Prefix"] += f"_sub{subdomain_idx}"
  # Set local mesh
  dict_repr["Mesh"] = manual_meshes[subdomain_idx]
  # Stringify initial condition x_global
  dict_repr["InitialCondition"]["x_global"] = x_global
  # Insert source time function lambdas
  if approx_massfracs:
    dict_repr["InitialCondition"]["yWt"] = Evaluable(str_yWt_source)
    dict_repr["InitialCondition"]["yC"] = Evaluable(str_yC_source)
  
  # Copy timestepping to 0th subdomain
  if subdomain_idx == 0:
    dict_repr["TimeStepping"] = primary_input.TimeStepping

  # Set boundary conditions
  dict_repr["BoundaryConditions"] = manual_bcs[subdomain_idx]
  if subdomain_idx == 0:
    dict_repr["BoundaryConditions"]["x1"]["cVFfunc"] = Evaluable(cVFfunc)
  # Link to next conduit subdomain
  dict_repr["LinkedSolvers"] = []
  if subdomain_idx < num_domains - 1:
    dict_repr["LinkedSolvers"] = [{
      "DeckName": param_filename_map(subdomain_idx+1),
      "BoundaryName": f"comm1D_{subdomain_idx}_{subdomain_idx+1}",
    }]
  elif is_coupled2D:
    dict_repr["LinkedSolvers"] = [{
      "DeckName": atm_param_filename_map(0),
      "BoundaryName": f"vent",
    }]

  # Generate the parameter file
  param_filename = param_filename_map(subdomain_idx)
  with io.open(param_filename, 'w') as f:
    # Write header
    f.write(header)
    # Write each dict in parameter file
    for k, v in dict_repr.items():
      f.write(f"{k} = {pprint.pformat(v)}\n\n")
