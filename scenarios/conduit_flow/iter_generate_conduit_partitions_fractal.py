import importlib, io, pprint

# Set primary input file name (without suffix .py)
input_module_name = "sm0_15_cvf75_fractal8s_diffSEED"

# Specify whether conduit is coupled to 2D atmosphere.
# If True, run `generate_atm_partitions.py`` as well to write the atmosphere
# files.
is_coupled2D = False

# Import primary input file
primary_input = importlib.import_module(input_module_name)

# Set header to write, including necessary imports
header = '''\'\'\' Input file generated by generate_conduit_partitions.py. \'\'\'

import numpy as np
import scipy.interpolate as si

def fractal_timeSeries(end_time, dt, SEED, Ch, max_freq):
  t = np.linspace(0,end_time+dt,int((end_time+dt) / dt))

  N = len(t) # number of Fourier sample points
  h = t[1]-t[0] # grid spacing, nominally h=0.1 km for r=1
  L = N*h # profile length

  # white noise, unit normal distribution
  randomGen = np.random.default_rng(seed=SEED)
  y = randomGen.normal(size=N)
  # scale so PSD has unit amplitude
  y = y*np.sqrt(N/L)

  omega = 2 * np.pi * np.fft.fftfreq(N, h)
  Y = np.fft.fft(y)*h

  # apply fractal PSD
  PSD_fractal = Ch * np.abs(omega)**(-3)
  PSD_fractal[np.abs(omega) > max_freq * 2 * np.pi] = 0

  Y_fractal = Y * np.sqrt(PSD_fractal)
  Y_fractal[0] = 0
  Y_fractal[-1] = 0
  PSDy_fractal = np.abs(Y_fractal)**2/L

  # transforming back into time domain
  y_fractal = np.fft.ifft(Y_fractal) / h
  y_fractal = np.real(y_fractal) - np.real(y_fractal)[0]

  fractal = si.interp1d(t, y_fractal, kind='cubic', bounds_error=False, fill_value="extrapolate")
  return fractal

CH = (2 * np.pi)**3 * (4 * 10**(-5))**2

'''

''' Specify mesh partition here ''' 

num_domains = 10
# Specify mesh partition (overriding the Mesh in primary_input)
num_elems_total = 2000
# Specify extent of domain
x_global_min = -1150
x_global_max = -150
if num_domains * (num_elems_total//num_domains) != num_elems_total:
  raise ValueError("Domain could not be split evenly into domain. Check that" +
    "num_elems_total is an integer multiple of num_domains.")

domain_length = x_global_max - x_global_min 
manual_meshes = [
  {
    "File" : None,
    "ElementShape" : "Segment",
    "NumElemsX" : num_elems_total//num_domains,
    "xmin" : x_global_min + (domain_length/num_domains)*i,
    "xmax" : x_global_min + (domain_length/num_domains)*(i+1),
  }
  for i in range(num_domains)
]
manual_bcs = [
  {
    "x1":{
      "BCType": "MultiphasevpT1D1D",
      "bkey": f"comm1D_{i-1}_{i}",
    },
    "x2":{
      "BCType": "MultiphasevpT1D1D",
      "bkey": f"comm1D_{i}_{i+1}",
    },
  }
  for i in range(num_domains)
]
# First BC at bottom is copied
manual_bcs[0]["x1"] = primary_input.BoundaryConditions["x1"]

# Set last BC at top of 1D domain
if is_coupled2D:
  manual_bcs[-1]["x2"] = { 
      "BCType" : "MultiphasevpT2D1D",
      "bkey" : "vent",
  }
else:
  manual_bcs[-1]["x2"] = { 
    "BCType" : "PressureOutlet1D",
    "p": 1e5,
  }

# Whether to approximate periodically forced mass fraction in space
approx_massfracs = True
# Define periodic source-time function as strings
str_yC_source = "lambda t: 0.4"
str_yWt_source = "lambda t: 0.03 * (1.0 - 0.4) / (1.0 + 0.03)"

totalTIME = primary_input.TimeStepping['FinalTime']

cVFfunc = lambda i, j: f"fractal_timeSeries({i}, 0.04, {j}, CH, 0.125)"

# Define name of the parameter file
param_filename_map = lambda j,i: f'seed{j}_conduit_sub{i}.py'
# Define name of the atm parameter files
atm_param_filename_map = lambda i: f'atm_sub{i}.py'

''' ==================== Machinery ==================== '''

# Designate fields to copy as default
fields_copy = ["Numerics", "Mesh", "Physics", "SourceTerms",
  "Output", "InitialCondition", "ExactSolution",
  "BoundaryConditions", "LinkedSolvers"]

class Evaluable():
  ''' Evaluable expression. Used if an expression needs to be embedded in the
  generated parameter file. This class allows evaluable expressions to be
  passed through pprint without adding quotation marks.'''

  def __init__(self, expr):
    self.expr = expr

  def __repr__(self):
    return self.expr

# Construct global mesh representation (uniform mesh)
#   Note that for SolutionOrder > 2, this does not correspond exactly to the
#   required DG nodes. This may cause numerical perturbation in the initial
#   condition setup.
#   Format of _subdomain_nodes[i] is (x_min, x_max, num_nodes)

# Get mesh representations as (x_min, x_max, N_nodes) in each subdomain mesh
if primary_input.Numerics["SolutionOrder"] == 0:
  # Compute dx for centering sampling nodes in 0th order elements
  _elt_sizes = [(mesh["xmax"] - mesh["xmin"]) / mesh["NumElemsX"]
    for mesh in manual_meshes]
  _subdomain_nodes = [(mesh["xmin"] + dx/2, mesh["xmax"] - dx/2,
    mesh["NumElemsX"]) for mesh, dx in zip(manual_meshes, _elt_sizes)]
else:
  # Compute node locations
  _subdomain_nodes = [(mesh["xmin"], mesh["xmax"],
    1 + primary_input.Numerics["SolutionOrder"] * mesh["NumElemsX"])
  for mesh in manual_meshes]
# Get evaluable expression for global mesh
evaluable_str = ', '.join(
  [f"np.linspace({arg[0]:.3e}, {arg[1]:.3e}, {arg[2]:d})"
  for arg in _subdomain_nodes])
x_global = Evaluable(f"np.unique(np.hstack([{evaluable_str}]))")

# Subdomain control
for SEED in range(5):
  for subdomain_idx in range(num_domains):
    # Initialize dictionary representation of parameter file to be written
    dict_repr = {field: getattr(primary_input, field).copy()
      for field in fields_copy}
    # Modify name for simulation output files
    dict_repr["Output"]["Prefix"] += f"_sub{subdomain_idx}_seed{SEED}"
    # Set local mesh
    dict_repr["Mesh"] = manual_meshes[subdomain_idx]
    # Stringify initial condition x_global
    dict_repr["InitialCondition"]["x_global"] = x_global
    # Insert source time function lambdas
    if approx_massfracs:
      dict_repr["InitialCondition"]["yWt"] = Evaluable(str_yWt_source)
      dict_repr["InitialCondition"]["yC"] = Evaluable(str_yC_source)
    
    # Copy timestepping to 0th subdomain
    if subdomain_idx == 0:
      dict_repr["TimeStepping"] = primary_input.TimeStepping
  
    # Set boundary conditions
    dict_repr["BoundaryConditions"] = manual_bcs[subdomain_idx]
    if subdomain_idx == 0:
      dict_repr["BoundaryConditions"]["x1"]["cVFfunc"] = Evaluable(cVFfunc(totalTIME, SEED))
    # Link to next conduit subdomain
    dict_repr["LinkedSolvers"] = []
    if subdomain_idx < num_domains - 1:
      dict_repr["LinkedSolvers"] = [{
        "DeckName": param_filename_map(SEED, subdomain_idx+1),
        "BoundaryName": f"comm1D_{subdomain_idx}_{subdomain_idx+1}",
      }]
    elif is_coupled2D:
      dict_repr["LinkedSolvers"] = [{
        "DeckName": atm_param_filename_map(0),
        "BoundaryName": f"vent",
      }]
  
    # Generate the parameter file
    param_filename = param_filename_map(SEED, subdomain_idx)
    with io.open(param_filename, 'w') as f:
      # Write header
      f.write(header)
      # Write each dict in parameter file
      for k, v in dict_repr.items():
        f.write(f"{k} = {pprint.pformat(v)}\n\n")
