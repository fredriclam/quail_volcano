import importlib, io, json, pprint

# Set primary input file name (without suffix .py)
input_module_name = "conduit"

# Import primary input file
primary_input = importlib.import_module(input_module_name)

# Set header to write, including necessary imports
header = '''\'\'\' Input file generated by generate_domainpartitions.py. \'\'\'

import numpy as np

'''

num_domains = 10
# Specify Mesh partition
manual_meshes = [
  {
    "File" : None,
    "ElementShape" : "Segment",
    "NumElemsX" : 1250//num_domains,
    "xmin" : -2500.0 + (2500/num_domains)*i,
    "xmax" : -2500.0 + (2500/num_domains)*(i+1),
  }
  for i in range(num_domains)
]
manual_bcs = [
  {
    "x1":{
      "BCType": "MultiphasevpT1D1D",
      "bkey": f"comm_{i-1}_{i}",
    },
    "x2":{
      "BCType": "MultiphasevpT1D1D",
      "bkey": f"comm_{i}_{i+1}",
    },
  }
  for i in range(num_domains)
]
# First BC at bottom is copied
manual_bcs[0]["x1"] = primary_input.BoundaryConditions["x1"]
# Last BC at top
manual_bcs[-1]["x2"] = { 
  "BCType" : "PressureOutlet1D",
  "p": 1e5,
}

# Import primary input file
primary_input = importlib.import_module(input_module_name)

# Check consistency with global mesh (TODO: in what sense?)
# [mesh["NumElemsX"] for mesh in manual_meshes] 
#   == len(primary_input.InitialCondition["x_global"])

# Define name of the parameter file
param_filename_map = lambda i: f'conduit_sub{i}.py'
# Designate fields to copy
fields_copy = ["Numerics", "Mesh", "Physics", "SourceTerms",
  "Output", "InitialCondition", "ExactSolution",
  "BoundaryConditions", "LinkedSolvers"]

# Code embedding through pprint
class Evaluable():

  def __init__(self, expr):
    self.expr = expr

  def __repr__(self):
    return self.expr


# Subdomain control
for subdomain_idx in range(num_domains):

  # Initialize dictionary representation of parameter file to be written
  dict_repr = {field: getattr(primary_input, field).copy()
    for field in fields_copy}

  # Modify name for simulation output files
  dict_repr["Output"]["Prefix"] += f"_sub{subdomain_idx}"
  # Set local mesh
  dict_repr["Mesh"] = manual_meshes[subdomain_idx]
  # Stringify initial condition x_global
  x_global = primary_input.InitialCondition["x_global"]
  dict_repr["InitialCondition"]["x_global"] = \
    Evaluable(f"np.linspace({x_global.min():.3e}, " \
    + f"{x_global.max():.3e}, {len(x_global)})")
  # Set boundary conditions
  dict_repr["BoundaryConditions"] = manual_bcs[subdomain_idx]
  # Set linked solver at x2
  if subdomain_idx == num_domains - 1:
    dict_repr["LinkedSolvers"] = []
  else:
    dict_repr["LinkedSolvers"] = [{
      "DeckName": param_filename_map(subdomain_idx+1),
      "BoundaryName": f"comm_{subdomain_idx}_{subdomain_idx+1}",
    }]

  # Copy timestepping to 0th subdomain
  if subdomain_idx == 0:
    dict_repr["TimeStepping"] = primary_input.TimeStepping

  # Generate the parameter file
  param_filename = param_filename_map(subdomain_idx)
  with io.open(param_filename, 'w') as f:
    # Write header
    f.write(header)
    # Write each dict in parameter file
    for k, v in dict_repr.items():
      f.write(f"{k} = {pprint.pformat(v)}\n\n")
