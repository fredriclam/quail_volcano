''' Generates partitions for atmosphere. Assumes that the root solver is
  at the base of the conduit, and thus does not link the conduit solver
  as a LinkedSolver here. Run this after generate_conduit_partitions.
  Does not handle TimeStepping (assumes conduit is the entry point). '''

import importlib, io, pprint

# Set primary input file name (without suffix .py)
input_module_name = "vent_region"

# Import primary input file
primary_input = importlib.import_module(input_module_name)

# Set header to write, including necessary imports
header = '''\'\'\' Input file generated by generate_atm_partitions.py. \'\'\'

import numpy as np

'''

''' Specify mesh partition here ''' 

num_domains = 3

# Select 2D mesh set by name
mesh_set = "volcano"
# Specify mesh partition
if mesh_set == "volcano":
  manual_meshes = [
    { "File" : f"../meshes/volcanoA{i+1}.msh", } for i in range(num_domains)
  ]
  if num_domains > 6:
    print("volcano has only 6 pieces. Check `num_domains`.")
elif mesh_set == "tungurahua":
  manual_meshes = [
    { "File" : f"../meshes/tungurahuaA{i+1}.msh", } for i in range(num_domains)
  ]
  if num_domains > 8:
    print("tungurahuaA has only 8 pieces. Check `num_domains`.")
else:
  raise ValueError("Unknown mesh set. Use volcano, tungurahua, or modify code.")
  
# Specify boundary conditions for each subdomain
#   Keys for boundary condition correspond to gmsh physical group names
manual_bcs = [ # tungurahuaA mesh
  {
    "r1" : { "BCType" : "MultiphasevpT2D2D", "bkey": "r1", },
    "ground" : { "BCType" : "SlipWall", },
    "flare" : { "BCType" : "SlipWall", },
    "pipewall" : { "BCType" : "SlipWall", },
    "x2" : { "BCType" : "MultiphasevpT2D1D", "bkey": "vent", },
    "symmetry" : { "BCType" : "SlipWall", },
  }, # atm0
  *[{
    f"ground{i+1}" : { "BCType" : "SlipWall", },
    f"symmetry{i+1}" : { "BCType" : "SlipWall", },
    f"r{i}" : { "BCType" : "MultiphasevpT2D2D", "bkey": f"r{i}", },
    f"r{i+1}" : { "BCType" : "MultiphasevpT2D2D", "bkey": f"r{i+1}", },
  } for i in range(1, num_domains)], # atm1+
]
# For backward compatibility using VolcanoA, rename some physical group
if num_domains > 1 and mesh_set == "volcano":
  manual_bcs[1]["ground_far"] = manual_bcs[1].pop("ground2")
  manual_bcs[1]["symmetry_far"] = manual_bcs[1].pop("symmetry2")
# Replace outermost boundary condition with an outflow
manual_bcs[num_domains-1][f"r{num_domains}"] = {
  "BCType" : "LinearizedImpedance2D",
}

# Define name of the parameter file
param_filename_map = lambda i: f'atm_sub{i}.py'
# Designate fields to copy as default
fields_copy = ["Numerics", "Physics", "SourceTerms",
  "Output", "InitialCondition", "ExactSolution",
  "BoundaryConditions", "LinkedSolvers"]

class Evaluable():
  ''' Evaluable expression. Used if an expression needs to be embedded in the
  generated parameter file. This class allows evaluable expressions to be
  passed through pprint without adding quotation marks.'''

  def __init__(self, expr):
    self.expr = expr

  def __repr__(self):
    return self.expr


# Subdomain control
for subdomain_idx in range(num_domains):
  # Initialize dictionary representation of parameter file to be written
  dict_repr = {field: getattr(primary_input, field).copy()
    for field in fields_copy}
  # Modify name for simulation output files
  dict_repr["Output"]["Prefix"] += f"_sub{subdomain_idx}"
  # Set local mesh
  dict_repr["Mesh"] = manual_meshes[subdomain_idx]
  # Set boundary conditions
  dict_repr["BoundaryConditions"] = manual_bcs[subdomain_idx]
  # Link to next atm subdomain
  if subdomain_idx < num_domains - 1:
    dict_repr["LinkedSolvers"] = [{
      "DeckName": param_filename_map(subdomain_idx+1),
      "BoundaryName": f"r{subdomain_idx+1}",
    }]
  else:
    dict_repr["LinkedSolvers"] = []

  # Generate the parameter file
  param_filename = param_filename_map(subdomain_idx)
  with io.open(param_filename, 'w') as f:
    # Write header
    f.write(header)
    # Write each dict in parameter file
    for k, v in dict_repr.items():
      f.write(f"{k} = {pprint.pformat(v)}\n\n")
