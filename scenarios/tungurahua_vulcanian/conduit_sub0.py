''' Sample input file for conduit in Vulcanian eruption. See below for instructions. '''

import numpy as np

# Numerical solver options. These options worked well in the past.
# Artificial viscosity keeps spurious oscillations in check, and the positivity-
# preserving limiter keeps variables like density, pressure positive.
# SolutionOrder specifies the order of polynomial to use as approximation basis.
# SolutionOrder = 2 means that the solution is piecewise quadratic.
Numerics = {'AVParameter': 0.3,
 'ApplyLimiters': 'PositivityPreservingMultiphasevpT',
 'ArtificialViscosity': True,
 'ElementQuadrature': 'GaussLegendre',
 'FaceQuadrature': 'GaussLegendre',
 'L2InitialCondition': True,
 'SolutionBasis': 'LagrangeSeg',
 'SolutionOrder': 2,
 'Solver': 'DG'}

# Specify the mesh here. The domain goes from xmin to xmax in NumElemsX
# elements.
Mesh = {'ElementShape': 'Segment',
 'File': None,
 'NumElemsX': 200,
 'xmax': -150.0,   # Top of the conduit is placed at -150 m for 2D coupling, but you can choose whatever if not coupling to 2D.
 'xmin': -1150.0
}

# Specify physical properties here.
# LaxFriedrichs is the numerical flux. This is a standard option, and does not
# typically need to be changed.
Physics = {'ConvFluxNumerical': 'LaxFriedrichs',
 'Gas1': {'R': 287.0, 'gamma': 1.4},
 'Gas2': {'R': 461.3762486126526, 'c_p': 2288.0},
 'Liquid': {'E_m0': 0,                # Ground state energy (0 is fine)
            'K': 10000000000.0,       # Bulk modulus of magma phase (Pa)
            'c_m': 3000.0,            # Heat capacity of magma phase (J / kg K)
            'p0': 35999999.99999999,  # Linearized magma EOS constant
            'rho0': 2600.0},          # Linearized magma EOS constant
 'Solubility': {'k': 5e-06, 'n': 0.5}, # Henry's law: max soluble mass fraction is = (k * p ** n) * yL
 'Type': 'MultiphasevpT',
 'Viscosity': {'mu0': 300000.0},      # Unused option (viscosity is specified in the source code for FrictionVolFracVariableMu)
 'tau_d': Exception("Deprecated")     # Unused. For exsolution timescale (s), see SourceTerms below.
}

SourceTerms = {'source1': {'Function': 'GravitySource', # Gravity
             'gravity': 9.8,
             'source_treatment': 'Explicit'},
 'source2': {'Function': 'FrictionVolFracVariableMu',   # Friction source term for given conduit radius
             'conduit_radius': 50,
             'source_treatment': 'Explicit'},
 'source3': {'Function': 'ExsolutionSource',            # Exsolution source
             'source_treatment': 'Explicit',
             'tau_d': 10.0,                             # Exsolution timescale
             },
 'source4': {'Function': 'FragmentationTimescaleSourceSmoothed',
             'crit_volfrac': 0.7,                       # Critical volume fraction
             'fragsmooth_scale': 0.05,                  # Fragmentation smoothing scale (for two-sided smoothing)
             'source_treatment': 'Explicit',
             'tau_f': 1.0,                              # Fragmentation timescale (s)
             }
}

Output = {'AutoPostProcess': False,
 'Prefix': 'tungurahua_test_conduit_sub0',              # Output filename
 'WriteInitialSolution': True,
 'WriteInterval': 540                                   # Output frequency (this many timesteps pass before file is written)
}

# Initial condition parameters
# Note that some parameters here are repeated, and must be consistent with the
# parameters specified in SourceTerms. It's hardcoded here because this
# file was generated by a script that writes parallelized input files.
InitialCondition = {'Function': 'SteadyState',          # Specify to call physics/multiphasevpT/functions > SteadyState as initial condition
 'K_magma': 10000000000.0,
 'T_chamber': 1050,                                     # Chamber temperature
 'approx_massfracs': True,
 'c_v_magma': 3000.0,
 'conduit_radius': 50,                                  # Chamber temperature
 'crit_volfrac': 0.7,
 'fragsmooth_scale': 0.05,
 'inlet_input_val': 40000000.0,
 'input_type': 'p',
 'neglect_edfm': True,
 'p0_magma': 35999999.99999999,
 'p_vent': 100000.0,
 'rho0_magma': 2600.0,
 'solubility_k': 5e-06,
 'solubility_n': 0.5,
 'tau_d': 10.0,
 'tau_f': 1.0,
 'x_global': np.linspace(Mesh["xmin"], Mesh["xmax"], Mesh["NumElemsX"]),
 'yA': 1e-07,
 'yC': lambda t: 0.4,
 'yCMin': 1e-05,
 'yWt': lambda t: 0.03 * (1.0 - 0.4) / (1.0 + 0.03),    # Inlet water
 'yWvInletMin': 1e-05}

# This is needed by Quail. This is not the exact solution, just something callable.
ExactSolution = {'Function': 'RiemannProblem'}

# Set boundary conditions here.
BoundaryConditions = {
  'x1': {'BCType': 'PressureStableLinearizedInlet1D',   # Inlet boundary condition
        'T_chamber': 1050,                              # Chamber temperature
        'cVFamp': 0.0,                                  # Amplitude of crystal fraction variation
        'cVFav': 0.4,                                   # Crystal fraction input
        'chi_water': 0.03,                              # Mass concenration of water
        'cos_freq': 0.25,                               # Frequency of crystal fraction variation
        'is_gaussian': False,                           # If true, use Gaussian variation instead of cosine
        'p_chamber': 40000000.0,                        # Chamber pressure
        'trace_arho': 2.6000000000000002e-05            # Trace density (for numerical stability)
},
 'x2': {'BCType': 'PressureOutlet1D',                   # Pressure outlet boundary condition (automatically chokes if needed)
        'p': 100000.0                                   # Boundary pressure (if flow not choked)
        },
  # For running in parallel, the following boundary condition type is needed:
  #  'x2': {'BCType': 'MultiphasevpT1D1D', 'bkey': 'comm1D_0_1'}
}

# Linked parallel solvers. If running in serial, leave as empty list.
LinkedSolvers = []
# A parallel solver would have multiple input files like this one, and they would
# be linked as follows:
#   LinkedSolvers = [{'BoundaryName': 'comm1D_0_1', 'DeckName': 'sin4s_conduit_sub1.py'}]

# Set timestepping options. The timestep size (dt) is calculated based on final
# time and NumTimeSteps. If a NonPhysicalError is returned, check here first to
# see if the CFL condition is met.
TimeStepping = {'FinalTime': 120, # Final 
 'InitialTime': 0.0,
 'NumTimeSteps': 1620000, # Number of timesteps to run for
 'TimeStepper': 'RK3SR',  # 4-step RK3 scheme that maximizes CFL stability region per function eval
}

