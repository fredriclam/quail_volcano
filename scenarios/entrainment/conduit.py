''' Sample input file for conduit in Vulcanian eruption. See below for instructions. '''

import numpy as np

# Numerical solver options. These options worked well in the past.
# Artificial viscosity keeps spurious oscillations in check, and the positivity-
# preserving limiter keeps variables like density, pressure positive.
# SolutionOrder specifies the order of polynomial to use as approximation basis.
# SolutionOrder = 2 means that the solution is piecewise quadratic.
Numerics = {'AVParameter': 0.3,
#  'ApplyLimiters': 'PositivityPreservingMultiphasevpT',
 'ArtificialViscosity': False, #True,
#  'ElementQuadrature': 'GaussLegendre',
#  'FaceQuadrature': 'GaussLegendre',
 'L2InitialCondition': True,
 'SolutionBasis': 'LagrangeSeg',
 'SolutionOrder': 0,#1,
 'Solver': 'DG'}

# Specify the mesh here. The domain goes from xmin to xmax in NumElemsX
# elements.
Mesh = {'ElementShape': 'Segment',
 'File': None,
 'NumElemsX': 400,
 'xmax': -50.0,   # Top of the conduit is placed at -150 m for 2D coupling, but you can choose whatever if not coupling to 2D.
 'xmin': -2050.0
}

# Specify physical properties here.
# LaxFriedrichs is the numerical flux. This is a standard option, and does not
# typically need to be changed.
Physics = {
    "Type" : "MultiphaseWLMA",
    "ConvFluxNumerical" : "LaxFriedrichs",
    "num_parallel_workers": 2,
}

SourceTerms = {'source1': {'Function': 'GravitySource', # Gravity
             'gravity': 9.8,
             'source_treatment': 'Explicit'},
#  'source2': {'Function': 'FrictionVolFracVariableMu',   # Friction source term for given conduit radius
#              'conduit_radius': 50,
#              'source_treatment': 'Explicit'},
#  'source3': {'Function': 'ExsolutionSource',            # Exsolution source
#              'source_treatment': 'Explicit',
#              'tau_d': 10.0,                             # Exsolution timescale
            #  },
#  'source4': {'Function': 'FragmentationTimescaleSourceSmoothed',
#              'crit_volfrac': 0.7,                       # Critical volume fraction
#              'fragsmooth_scale': 0.05,                  # Fragmentation smoothing scale (for two-sided smoothing)
#              'source_treatment': 'Explicit',
#              'tau_f': 1.0,                              # Fragmentation timescale (s)
#              }
#  'source5': {'Function': 'WaterMassSource',
#              'mass_rate': 0.0,
#              'specific_energy': 109388.56885035457,
#              'injection_depth': -50-75,
#              'gaussian_width': 75,
#              'conduit_radius': 50,
#              }
}

Output = {'AutoPostProcess': False,
#  'Prefix': 'ringfault_above_ocean_conduit4',              # Output filename
 'Prefix': 'ringfault_above_ocean_conduit4_1175plus',              # Output filename
 'WriteInitialSolution': True,
 'WriteInterval': 20,                                   # Output frequency (this many timesteps pass before file is written)
}

Restart = {
	"File" : "ringfault_above_ocean_conduit4_1175.pkl",
	"StartFromFileTime" : True
}

# Define a traction function
def gaussian_traction(x:np.array, total_pressure_change=10e6, x0=-350, sigma=50) -> np.array:
  ''' Traction function added to the hydrostatic equation. Negative
   sign indicates downward traction on the fluid. Units are Pa / m. 
   Total pressure change due to traction is amp * sigma.
   Inputs:
     x: array of points at which traction is evaluated
     total_pressure_change: total pressure change across the traction. The
       Gaussian amplitude is calculated from this.
     x0: Gaussian center (m)
     sigma: standard deviation parameter (length scale of traction function)
   '''
  # Compute amplitude of Gaussian TODO:
  amplitude = total_pressure_change / (np.sqrt(np.pi) * sigma)
  _t = (x-x0)/sigma
  return -amplitude * np.exp(-_t * _t)

# Set common parameters
p_chamber = 20e6
T_chamber = 1050
yC = 0.1    # Crystal mass fraction
yWt = 0.03  # Total water mass fraction

chi_water = (1.0 - yC) * yWt / (1 - yWt)


# Initial condition parameters
# Note that some parameters here are repeated, and must be consistent with the
# parameters specified in SourceTerms. It's hardcoded here because this
# file was generated by a script that writes parallelized input files.
InitialCondition = {
  'Function': 'UnderwaterMagmaConduit',
  "T_magma": 1100 + 273.15,
  "T_water": 300,
  "psurf": 1e5, # Pressure at ocean surface
  "hsurf": 0.0,
	"hwm": -150, #-50, #Water magma interface height
  "hmin": Mesh["xmin"],#-2050,
  "delta_p": 10e6,
  "yC": 1e-7,
  "yWt": 0.05,
	"solubility_k": 5e-6,
  "solubility_n": 0.5,
}

# This is needed by Quail. This is not the exact solution, just something callable.
ExactSolution = {'Function': 'UnderwaterMagmaConduit'}

# Set boundary conditions here.
BoundaryConditions = {
#   'x1': {'BCType': 'PressureStableLinearizedInlet1D',   # Inlet boundary condition
#         'T_chamber': T_chamber,                         # Chamber temperature
#         'cVFamp': 0.0,                                  # Amplitude of crystal fraction variation
#         'cVFav': yC,                                    # Crystal fraction input
#         'chi_water': chi_water,                         # Mass concentration of water
#         'cos_freq': 0.25,                               # Frequency of crystal fraction variation
#         'is_gaussian': False,                           # If true, use Gaussian variation instead of cosine
#         'p_chamber': p_chamber,                         # Chamber pressure
#         'trace_arho': 2.6000000000000002e-05,           # Trace density (for numerical stability)
#         'approx_mass_fracs': False,                     # Compute exactly the mass fraction of inlet fluid
#         'solubility_k': 5e-06,                          # Henry's law coefficient
#         'solubility_n': 0.5,                            # Henry's law exponent
# },
  'x1': {
    "BCType": "SlipWall",
  },
  # For running serial, using p boundary condition:
#  'x2': {'BCType': 'PressureOutlet1D',                   # Pressure outlet boundary condition (automatically chokes if needed)
#         'p': 100000.0                                   # Boundary pressure (if flow not choked)
#         },
  'x2': {'BCType': 'MultiphasevpT2D1D',                   # Pressure outlet boundary condition (automatically chokes if needed)
  "bkey": "x2"                                   # Boundary pressure (if flow not choked)
  },
  # For running in parallel, the following boundary condition type is needed:
#    'x2': {'BCType': 'MultiphasevpT1D1D',
        #   'bkey': 'comm2D1D'}
}

# Linked parallel solvers. If running in serial, leave as empty list.
LinkedSolvers = []
# A parallel solver would have multiple input files like this one, and they would
# be linked as follows:
# LinkedSolvers = [{'BoundaryName': 'comm2D1D',
#                   'DeckName': 'vent_region.py'}]

# Set timestepping options. The timestep size (dt) is calculated based on final
# time and NumTimeSteps. If a NonPhysicalError is returned, check here first to
# see if the CFL condition is met.
# TimeStepping = {
# 	"InitialTime" : 0.0,
# 	"FinalTime" : 10,
# 	"NumTimeSteps" : 10*700, # 2500 per second is ok # min mesh edge length: 6.2; about 600 is min
# 	"TimeStepper" : "RK3SR",
# }